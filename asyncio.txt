Asyncio - предоставляет функциональность для управления событийным циклом(event loop). Т.к. центральной концепцией в asyncio является цикл событий,
все методы применяемые к модулю asyncio, так или иначе влияют на него. Например метод asyncio.run(coro) запустит указанную корутину в цикле событий,
или asyncio.sleep() укажет циклу событий на то, что в конкретной корутине необходимо "поспать". Таким же образом, перечисленные ниже методы будут взаимодействовать с циклом событий.
Напомню: цикл событий – это такая конструкция, которая не только ожидает и отправляет события или задачи на выполнение, но так же, следит за ходом выполнения каждой
корутины, и их статуcом. Каждая корутина запущенная в цикле событий, общается "сообщениями" под капотом, передавая информацию о своём статусе, для эффективного управления ими.
Когда ваша программа включает в себя множество асинхронных операций, цикл событий может управлять их выполнением, переключаясь между задачами в оптимальном порядке.
Вот короткое описание основных методов, которые предоставляет этот модуль, детальное описание всех аргументов каждого метода с примерами кода, в следующих степах:
asyncio.run(coro, *, debug=False)  - создаёт цикл событий и запускает указанный coroutine в нём, после завершения работы выполнения coro, автоматически закрывает цикл
событий при завершении. Этот метод является основным методом для запуска и управления asyncio приложениями.
asyncio.sleep(delay, result=None, *, loop=None) - приостанавливает выполнение текущей корутины на delay секунд.
asyncio.create_task(coro, *, name=None) - оборачивает coro в обёртку задачи, т.е. она будет запланирована для выполнения в цикле событий.
    Доступные методы класса Task
    task.done() - возвращает True, если задача выполнена или отменена. Этот метод удобно использовать, чтобы проверить, закончила ли задача свое выполнение, чтобы начать следующую задачу;
    asyncio.current_task() - возвращает объект задачи, выполняющейся в текущем потоке. Этот метод может быть полезен, если вы хотите узнать, какая задача выполняется в данный момент;
    task.result() - возвращает результат выполнения задачи, если она выполнена. Если результат задачи еще не доступен, то метод вызывает исключение InvalidStateError .
    Этот метод может быть полезен, если вы хотите получить результат выполнения задачи;
    asyncio.all_tasks(loop=None) - возвращает множество всех запущенных задач. Этот метод может быть полезен, если вы хотите получить список всех задач, которые были запущены;
    task.get_name() - возвращает имя задачи. Этот метод может быть полезен, если вы хотите узнать имя задачи;
    task.set_name(name) - устанавливает имя задачи. Этот метод может быть полезен, если вы хотите установить имя задачи;
    task.exception() - возвращает исключение, которое было выброшено при выполнении задачи. Если задача еще не выполнена или не выбрасывала исключение, то метод возвращает None.
    Этот метод может быть полезен, если вы хотите получить информацию об исключении, выброшенном при выполнении задачи;
    task.cancel() - отменяет выполнение задачи. Он отправляет запрос на отмену, но не гарантирует, что задача будет немедленно остановлена.
    Задача будет остановлена только в том случае, если она имеет возможность обработать исключение asyncio.CancelledError
    task.cancelled() - используется для проверки, была ли задача отменена. Он возвращает True, если задача отменена, и False в противном случае.
    Когда задача отменяется, она переходит в состояние CANCELLED
    task.cancelling() - используется для проверки, находится ли задача в процессе отмены. Он возвращает True, если задача в процессе отмены, и False в противном случае.
    task.uncancel() -  используется для отмены запроса на отмену задачи. Он предотвращает отмену задачи, если она еще не была остановлена,  то есть, если задача была отменена,
    но мы вызвали метод task.uncancel(), то задача перейдет из состояния CANCELLED в состояние RUNNING.
    task.get_coro() - возвращает корутину, связанную с задачей. Этот метод может быть полезен, если вы хотите получить объект корутины, связанный с задачей;
        - task.get_coro().send(value) - Этот метод используется для отправки значения в корутину и продолжения ее выполнения с места, где она была приостановлена с использованием выражения yield.
        Однако в асинхронном коде с использованием asyncio вы должны использовать асинхронные механизмы, такие как asyncio.create_task() и await, чтобы дождаться выполнения корутины.
        - task.get_coro().throw(exc_type[, exc_value[, traceback]]) - Этот метод используется для возбуждения исключения в корутине. Он возбуждает указанное исключение в месте, где корутина
        была приостановлена, и продолжает ее выполнение с этого места. Если корутина обрабатывает исключение, она может продолжить выполнение с помощью выражения yield. Если корутина не
        обрабатывает исключение, выполнение корутины завершается с ошибкой, и исключение передается обратно вызывающему коду.
        - task.get_coro().close() - Этот метод используется для принудительного завершения корутины. Он возбуждает специальное исключение GeneratorExit в корутине, которое должно быть обработано
        корутиной или вызывающим кодом. Если корутина обрабатывает исключение GeneratorExit, она должна либо завершиться, либо возбудить исключение GeneratorExit снова. Если корутина
        не обрабатывает исключение GeneratorExit, выполнение корутины завершается без ошибок.
    task.get_loop() - возвращает цикл событий, связанный с задачей. Этот метод может быть полезен, если вы хотите получить объект цикла событий, связанный с задачей;
        task.get_loop() получает цикл событий из контекста объекта Task, а asyncio.get_event_loop() получает его из текущего контекста исполнения
    task.print_stack(* , limit = None , file = None) - возвращает стек выполнения задачи. Этот метод может быть полезен, если вы хотите получить информацию о стеке выполнения задачи;
        limit - Этот аргумент указывает максимальное количество записей стека вызовов, которые будут выведены.
            Если limit равен None, выводятся все записи стека вызовов.
            Если limit задан числом, будут выведены только указанное количество последних записей стека.
            Если limit меньше или равен 0, вывод стека вызовов будет отключен.
        file - Этот аргумент указывает файл, в который будет записан вывод стека вызовов.
            Если file равен None, вывод будет отправлен в стандартный поток вывода (sys.stdout). В противном случае file должен быть файловым объектом с поддержкой метода write().
    task.add_done_callback(fn) - добавляет функцию обратного вызова, которая будет вызвана после завершения выполнения задачи. Этот метод может быть полезен, если вы хотите выполнить
    какой-то код после того, как задача завершится;
    task.remove_done_callback(fn) - удаляет функцию обратного вызова, связанную с задачей. Этот метод может быть полезен, если вы хотите удалить функцию обратного вызова,
    которую ранее добавили в задачу;

asyncio.wait_for(coro, timeout, *, loop=None) - ожидает завершения coro, и если выполнение не завершено в течение timeout секунд, вызывается asyncio.TimeoutError.
asyncio.gather(*aws, loop=None, return_exceptions=False) - конкурентно запускает awaitable объекты, переданные в функцию как последовательность *aws и собирает результаты их работы.
asyncio.wait(fs, *, loop=None, timeout=None, return_when=ALL_COMPLETED) - возвращает кортеж из двух множеств Task/Future в виде (done, pending). Это позволяет вам узнать,
какие задачи были выполнены, и какие еще ожидают выполнения.
asyncio.ensure_future(coro_or_future, *, loop=None) - оборачивает корутину coro_or_future в Future и запускает ее.
asyncio.get_event_loop() - метод возвращает текущий цикл событий для текущего контекста.
asyncio.new_event_loop() - метод создает новый цикл событий.
asyncio.set_event_loop(loop) - метод устанавливает цикл событий для текущего контекста.
asyncio.get_running_loop() - метод возвращает текущий запущенный цикл событий в текущем потоке ОС. Вызывает исключение RuntimeError, если нет запущенного цикла событий.
asyncio.shield() - создает объект shield, который может использоваться для защиты кода от воздействия внешних циклов событий или от отмены с помощью  Task.cancel()
asyncio.run_until_complete(future) - метод запускает цикл событий, пока future не выполнится.
asyncio.run_coroutine_threadsafe(coro, loop) - метод является потокобезопасным и предназначен для запуска корутины в указанном цикле событий.

lock = asyncio.Lock()
Основные методы для работы с объектом блокировки – это acquire() и release(). Метод acquire() позволяет получить блокировку, а метод release() – освободить ее.
Метод acquire()являются асинхронными и должен быть вызван с использованием ключевого слова await, в то время как release() вызывается напрямую без await.
await lock.acquire()
# Критическая секция кода
lock.release()

Мьютексы могут быть использованы с помощью менеджера контекста with:
async with позволяет выполнять код внутри блока без блокирования и автоматически освобождать ресурсы после завершения выполнения блока.
Для того чтобы объект мог быть использован в блоке async with, он должен быть асинхронным контекстным менеджером.
Асинхронный контекстный менеджер - это объект, который определяет два асинхронных метода: __aenter__ подготовка ресурсов и __aexit__ особождение ресурсов и корректное завершение.

async with lock:
    # Критическая секция кода

async for предназначен для работы с асинхронными генераторами, которые возвращают объекты, поддерживающие асинхронное итерирование, не блокируя выполнение других задач.,
Итерация через коллекции, не блокируя событийный цикл

Отличие asyncio.get_event_loop() от asyncio.get_running_loop()

Методы asyncio.get_event_loop() и asyncio.get_running_loop() используются для получения текущего цикла событий, но они работают немного по-разному.
asyncio.get_event_loop() возвращает текущий цикл событий для текущего контекста выполнения. Если текущий цикл событий еще не установлен, метод get_event_loop()
будет пытаться установить новый цикл событий и вернуть его. Если цикл событий не может быть получен или установлен, get_event_loop() вызовет ошибку.
С другой стороны, asyncio.get_running_loop() возвращает текущий цикл событий только если он активно выполняется. Если цикл событий не запущен, get_running_loop()
вызовет ошибку RuntimeError. Этот метод полезен, когда вы хотите быть уверены, что ваш код выполняется в контексте запущенного цикла событий.
В общем, asyncio.get_running_loop() более строгий, и его использование может помочь избежать некоторых ошибок, связанных с попытками использовать цикл событий, который еще не запущен.

Очередь - это абстрактный тип данных, который поддерживает две основные операции: добавление элемента в очередь (enqueue) и извлечение элемента из очереди (dequeue).
    asyncio.Queue() FIFO (First-In-First-Out) - Простая реализация очереди для использования в асинхронном коде, типа "первым пришел - первым ушел" .
    asyncio.LifoQueue()  LIFO (Last In, First Out) - Реализация очереди в коде, типа "последним пришел, первым ушел" для использования в асинхронном коде.
    asyncio.PriorityQueue() - Реализация очереди с приоритетами для использования в асинхронном коде.