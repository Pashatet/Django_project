Asyncio - предоставляет функциональность для управления событийным циклом(event loop). Т.к. центральной концепцией в asyncio является цикл событий,
все методы применяемые к модулю asyncio, так или иначе влияют на него. Например метод asyncio.run(coro) запустит указанную корутину в цикле событий,
или asyncio.sleep() укажет циклу событий на то, что в конкретной корутине необходимо "поспать". Таким же образом, перечисленные ниже методы будут взаимодействовать с циклом событий.
Напомню: цикл событий – это такая конструкция, которая не только ожидает и отправляет события или задачи на выполнение, но так же, следит за ходом выполнения каждой
корутины, и их статуcом. Каждая корутина запущенная в цикле событий, общается "сообщениями" под капотом, передавая информацию о своём статусе, для эффективного управления ими.
Когда ваша программа включает в себя множество асинхронных операций, цикл событий может управлять их выполнением, переключаясь между задачами в оптимальном порядке.
Вот короткое описание основных методов, которые предоставляет этот модуль, детальное описание всех аргументов каждого метода с примерами кода, в следующих степах:
asyncio.run(coro, *, debug=False)  - создаёт цикл событий и запускает указанный coroutine в нём, после завершения работы выполнения coro, автоматически закрывает цикл
событий при завершении. Этот метод является основным методом для запуска и управления asyncio приложениями.
asyncio.sleep(delay, result=None, *, loop=None) - приостанавливает выполнение текущей корутины на delay секунд.
asyncio.create_task(coro, *, name=None) - оборачивает coro в обёртку задачи, т.е. она будет запланирована для выполнения в цикле событий.
asyncio.wait_for(coro, timeout, *, loop=None) - ожидает завершения coro, и если выполнение не завершено в течение timeout секунд, вызывается asyncio.TimeoutError.
asyncio.gather(*aws, loop=None, return_exceptions=False) - конкурентно запускает awaitable объекты, переданные в функцию как последовательность *aws и собирает результаты их работы.
asyncio.wait(fs, *, loop=None, timeout=None, return_when=ALL_COMPLETED) - возвращает кортеж из двух множеств Task/Future в виде (done, pending). Это позволяет вам узнать,
какие задачи были выполнены, и какие еще ожидают выполнения.
asyncio.ensure_future(coro_or_future, *, loop=None) - оборачивает корутину coro_or_future в Future и запускает ее.
asyncio.get_event_loop() - метод возвращает текущий цикл событий для текущего контекста.
asyncio.new_event_loop() - метод создает новый цикл событий.
asyncio.set_event_loop(loop) - метод устанавливает цикл событий для текущего контекста.
asyncio.get_running_loop() - метод возвращает текущий запущенный цикл событий в текущем потоке ОС. Вызывает исключение RuntimeError, если нет запущенного цикла событий.
asyncio.shield() - создает объект shield, который может использоваться для защиты кода от воздействия внешних циклов событий или от отмены с помощью  Task.cancel()
asyncio.run_until_complete(future) - метод запускает цикл событий, пока future не выполнится.
asyncio.run_coroutine_threadsafe(coro, loop) - метод является потокобезопасным и предназначен для запуска корутины в указанном цикле событий.

lock = asyncio.Lock()
Основные методы для работы с объектом блокировки – это acquire() и release(). Метод acquire() позволяет получить блокировку, а метод release() – освободить ее.
Метод acquire()являются асинхронными и должен быть вызван с использованием ключевого слова await, в то время как release() вызывается напрямую без await.
await lock.acquire()
# Критическая секция кода
lock.release()

Мьютексы могут быть использованы с помощью менеджера контекста with:
async with lock:
    # Критическая секция кода

Отличие asyncio.get_event_loop() от asyncio.get_running_loop()

Методы asyncio.get_event_loop() и asyncio.get_running_loop() используются для получения текущего цикла событий, но они работают немного по-разному.
asyncio.get_event_loop() возвращает текущий цикл событий для текущего контекста выполнения. Если текущий цикл событий еще не установлен, метод get_event_loop()
будет пытаться установить новый цикл событий и вернуть его. Если цикл событий не может быть получен или установлен, get_event_loop() вызовет ошибку.
С другой стороны, asyncio.get_running_loop() возвращает текущий цикл событий только если он активно выполняется. Если цикл событий не запущен, get_running_loop()
вызовет ошибку RuntimeError. Этот метод полезен, когда вы хотите быть уверены, что ваш код выполняется в контексте запущенного цикла событий.
В общем, asyncio.get_running_loop() более строгий, и его использование может помочь избежать некоторых ошибок, связанных с попытками использовать цикл событий, который еще не запущен.