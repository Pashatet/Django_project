Asyncio - предоставляет функциональность для управления событийным циклом(event loop). Т.к. центральной концепцией в asyncio является цикл событий,
все методы применяемые к модулю asyncio, так или иначе влияют на него. Например метод asyncio.run(coro) запустит указанную корутину в цикле событий,
или asyncio.sleep() укажет циклу событий на то, что в конкретной корутине необходимо "поспать". Таким же образом, перечисленные ниже методы будут взаимодействовать с циклом событий.
Напомню: цикл событий – это такая конструкция, которая не только ожидает и отправляет события или задачи на выполнение, но так же, следит за ходом выполнения каждой
корутины, и их статуcом. Каждая корутина запущенная в цикле событий, общается "сообщениями" под капотом, передавая информацию о своём статусе, для эффективного управления ими.
Когда ваша программа включает в себя множество асинхронных операций, цикл событий может управлять их выполнением, переключаясь между задачами в оптимальном порядке.
Вот короткое описание основных методов, которые предоставляет этот модуль, детальное описание всех аргументов каждого метода с примерами кода, в следующих степах:
asyncio.run(coro, *, debug=False)  - создаёт цикл событий и запускает указанный coroutine в нём, после завершения работы выполнения coro, автоматически закрывает цикл
событий при завершении. Этот метод является основным методом для запуска и управления asyncio приложениями.
asyncio.sleep(delay, result=None, *, loop=None) - приостанавливает выполнение текущей корутины на delay секунд.
asyncio.create_task(coro, *, name=None) - оборачивает coro в обёртку задачи, т.е. она будет запланирована для выполнения в цикле событий.
    Доступные методы класса Task
    task.done() - возвращает True, если задача выполнена или отменена. Этот метод удобно использовать, чтобы проверить, закончила ли задача свое выполнение, чтобы начать следующую задачу;
    asyncio.current_task() - возвращает объект задачи, выполняющейся в текущем потоке. Этот метод может быть полезен, если вы хотите узнать, какая задача выполняется в данный момент;
    task.result() - возвращает результат выполнения задачи, если она выполнена. Если результат задачи еще не доступен, то метод вызывает исключение InvalidStateError .
    Этот метод может быть полезен, если вы хотите получить результат выполнения задачи;
    asyncio.all_tasks(loop=None) - возвращает множество всех запущенных задач. Этот метод может быть полезен, если вы хотите получить список всех задач, которые были запущены;
    task.get_name() - возвращает имя задачи. Этот метод может быть полезен, если вы хотите узнать имя задачи;
    task.set_name(name) - устанавливает имя задачи. Этот метод может быть полезен, если вы хотите установить имя задачи;
    task.exception() - возвращает исключение, которое было выброшено при выполнении задачи. Если задача еще не выполнена или не выбрасывала исключение, то метод возвращает None.
    Этот метод может быть полезен, если вы хотите получить информацию об исключении, выброшенном при выполнении задачи;
    task.cancel() - отменяет выполнение задачи. Он отправляет запрос на отмену, но не гарантирует, что задача будет немедленно остановлена.
    Задача будет остановлена только в том случае, если она имеет возможность обработать исключение asyncio.CancelledError
    task.cancelled() - используется для проверки, была ли задача отменена. Он возвращает True, если задача отменена, и False в противном случае.
    Когда задача отменяется, она переходит в состояние CANCELLED
    task.cancelling() - используется для проверки, находится ли задача в процессе отмены. Он возвращает True, если задача в процессе отмены, и False в противном случае.
    task.uncancel() -  используется для отмены запроса на отмену задачи. Он предотвращает отмену задачи, если она еще не была остановлена,  то есть, если задача была отменена,
    но мы вызвали метод task.uncancel(), то задача перейдет из состояния CANCELLED в состояние RUNNING.
    task.get_coro() - возвращает корутину, связанную с задачей. Этот метод может быть полезен, если вы хотите получить объект корутины, связанный с задачей;
        - task.get_coro().send(value) - Этот метод используется для отправки значения в корутину и продолжения ее выполнения с места, где она была приостановлена с использованием выражения yield.
        Однако в асинхронном коде с использованием asyncio вы должны использовать асинхронные механизмы, такие как asyncio.create_task() и await, чтобы дождаться выполнения корутины.
        - task.get_coro().throw(exc_type[, exc_value[, traceback]]) - Этот метод используется для возбуждения исключения в корутине. Он возбуждает указанное исключение в месте, где корутина
        была приостановлена, и продолжает ее выполнение с этого места. Если корутина обрабатывает исключение, она может продолжить выполнение с помощью выражения yield. Если корутина не
        обрабатывает исключение, выполнение корутины завершается с ошибкой, и исключение передается обратно вызывающему коду.
        - task.get_coro().close() - Этот метод используется для принудительного завершения корутины. Он возбуждает специальное исключение GeneratorExit в корутине, которое должно быть обработано
        корутиной или вызывающим кодом. Если корутина обрабатывает исключение GeneratorExit, она должна либо завершиться, либо возбудить исключение GeneratorExit снова. Если корутина
        не обрабатывает исключение GeneratorExit, выполнение корутины завершается без ошибок.
    task.get_loop() - возвращает цикл событий, связанный с задачей. Этот метод может быть полезен, если вы хотите получить объект цикла событий, связанный с задачей;
        task.get_loop() получает цикл событий из контекста объекта Task, а asyncio.get_event_loop() получает его из текущего контекста исполнения
    task.print_stack(* , limit = None , file = None) - возвращает стек выполнения задачи. Этот метод может быть полезен, если вы хотите получить информацию о стеке выполнения задачи;
        limit - Этот аргумент указывает максимальное количество записей стека вызовов, которые будут выведены.
            Если limit равен None, выводятся все записи стека вызовов.
            Если limit задан числом, будут выведены только указанное количество последних записей стека.
            Если limit меньше или равен 0, вывод стека вызовов будет отключен.
        file - Этот аргумент указывает файл, в который будет записан вывод стека вызовов.
            Если file равен None, вывод будет отправлен в стандартный поток вывода (sys.stdout). В противном случае file должен быть файловым объектом с поддержкой метода write().
    task.add_done_callback(fn) - добавляет функцию обратного вызова, которая будет вызвана после завершения выполнения задачи. Этот метод может быть полезен, если вы хотите выполнить
    какой-то код после того, как задача завершится;
    task.remove_done_callback(fn) - удаляет функцию обратного вызова, связанную с задачей. Этот метод может быть полезен, если вы хотите удалить функцию обратного вызова,
    которую ранее добавили в задачу;

asyncio.wait_for(coro, timeout, *, loop=None) - ожидает завершения coro, и если выполнение не завершено в течение timeout секунд, вызывается asyncio.TimeoutError.
asyncio.gather(*aws, loop=None, return_exceptions=False) - конкурентно запускает awaitable объекты, переданные в функцию как последовательность *aws и собирает результаты их работы.
asyncio.wait(fs, *, loop=None, timeout=None, return_when=ALL_COMPLETED) - возвращает кортеж из двух множеств Task/Future в виде (done, pending). Это позволяет вам узнать,
какие задачи были выполнены, и какие еще ожидают выполнения.
asyncio.ensure_future(coro_or_future, *, loop=None) - оборачивает корутину coro_or_future в Future и запускает ее.
asyncio.get_event_loop() - метод возвращает текущий цикл событий для текущего контекста.
asyncio.new_event_loop() - метод создает новый цикл событий.
asyncio.set_event_loop(loop) - метод устанавливает цикл событий для текущего контекста.
asyncio.get_running_loop() - метод возвращает текущий запущенный цикл событий в текущем потоке ОС. Вызывает исключение RuntimeError, если нет запущенного цикла событий.
asyncio.shield() - создает объект shield, который может использоваться для защиты кода от воздействия внешних циклов событий или от отмены с помощью  Task.cancel()
asyncio.run_until_complete(future) - метод запускает цикл событий, пока future не выполнится.
asyncio.run_coroutine_threadsafe(coro, loop) - метод является потокобезопасным и предназначен для запуска корутины в указанном цикле событий.

lock = asyncio.Lock()
Основные методы для работы с объектом блокировки – это acquire() и release(). Метод acquire() позволяет получить блокировку, а метод release() – освободить ее.
Метод acquire()являются асинхронными и должен быть вызван с использованием ключевого слова await, в то время как release() вызывается напрямую без await.
await lock.acquire()
# Критическая секция кода
lock.release()

Мьютексы могут быть использованы с помощью менеджера контекста with:
async with позволяет выполнять код внутри блока без блокирования и автоматически освобождать ресурсы после завершения выполнения блока.
Для того чтобы объект мог быть использован в блоке async with, он должен быть асинхронным контекстным менеджером.
Асинхронный контекстный менеджер - это объект, который определяет два асинхронных метода: __aenter__ подготовка ресурсов и __aexit__ особождение ресурсов и корректное завершение.

async with lock:
    # Критическая секция кода

async for предназначен для работы с асинхронными генераторами, которые возвращают объекты, поддерживающие асинхронное итерирование, не блокируя выполнение других задач.,
Итерация через коллекции, не блокируя событийный цикл

Отличие asyncio.get_event_loop() от asyncio.get_running_loop()

Методы asyncio.get_event_loop() и asyncio.get_running_loop() используются для получения текущего цикла событий, но они работают немного по-разному.
asyncio.get_event_loop() возвращает текущий цикл событий для текущего контекста выполнения. Если текущий цикл событий еще не установлен, метод get_event_loop()
будет пытаться установить новый цикл событий и вернуть его. Если цикл событий не может быть получен или установлен, get_event_loop() вызовет ошибку.
С другой стороны, asyncio.get_running_loop() возвращает текущий цикл событий только если он активно выполняется. Если цикл событий не запущен, get_running_loop()
вызовет ошибку RuntimeError. Этот метод полезен, когда вы хотите быть уверены, что ваш код выполняется в контексте запущенного цикла событий.
В общем, asyncio.get_running_loop() более строгий, и его использование может помочь избежать некоторых ошибок, связанных с попытками использовать цикл событий, который еще не запущен.

Очередь - это абстрактный тип данных, который поддерживает две основные операции: добавление элемента в очередь (enqueue) и извлечение элемента из очереди (dequeue).
Очередь — это структура данных, в которую элементы могут быть добавлены вызовом put() и из которых элементы могут быть извлечены вызовом get().
    asyncio.Queue() FIFO (First-In-First-Out) - Простая реализация очереди для использования в асинхронном коде, типа "первым пришел - первым ушел" .
    https://stepik.org/lesson/933720/step/1?unit=939619
    asyncio.LifoQueue()  LIFO (Last In, First Out) - Реализация очереди в коде, типа "последним пришел, первым ушел" для использования в асинхронном коде.
    asyncio.PriorityQueue() - Реализация очереди с приоритетами для использования в асинхронном коде.




Race Condition (состояние гонки) - это состояние, когда два или более потока (или корутины) пытаются получить доступ к одному и тому же ресурсу одновременно.
Мьютекс (от англ. "mutual exclusion") — это механизм синхронизации, который используется для предотвращения одновременного доступа к общему ресурсу
Deadlock (тупик) – это ситуация, при которой несколько задач находятся в состоянии ожидания ресурсов (или завершения других задач), занятых друг другом, и ни одна из них не может продолжать свое выполнение. 


async def main():
    task = [asyncio.create_task(reserve_book(user)) for user in reservation_tasks]
    await asyncio.gather(*task)




 import asyncio

async def producer(queues, patient_info):
    """Регистрирует пациентов и направляет их в соответствующую очередь."""
    for patient in patient_info:
        await queues[patient['direction']].put(patient)
        print(f"Регистратор добавил в очередь: {patient['name']}, направление: {patient['direction']}, процедура: {patient['procedure']}")
        await asyncio.sleep(0.1)  # Имитация времени регистрации

async def consumer(queue, doctor_type):
    """Обрабатывает пациентов из очереди."""
    while True:
        patient = await queue.get()
        print(f"{doctor_type} принял пациента: {patient['name']}, процедура: {patient['procedure']}")
        await asyncio.sleep(0.4)  # Имитация времени приема
        queue.task_done()

async def main():
    patient_info = [
        {'name': 'Алексей Иванов', 'direction': 'Терапевт', 'procedure': 'Прием для общего осмотра'},
        {'name': 'Мария Петрова', 'direction': 'Хирург', 'procedure': 'Малая операция'},
        {'name': 'Ирина Сидорова', 'direction': 'ЛОР', 'procedure': 'Осмотр уха'},
        {'name': 'Владимир Кузнецов', 'direction': 'Терапевт', 'procedure': 'Консультация'},
        {'name': 'Елена Васильева', 'direction': 'Хирург', 'procedure': 'Хирургическая процедура'},
        {'name': 'Дмитрий Николаев', 'direction': 'ЛОР', 'procedure': 'Промывание носа'},
        {'name': 'Светлана Михайлова', 'direction': 'Терапевт', 'procedure': 'Рутинный осмотр'},
        {'name': 'Никита Алексеев', 'direction': 'Хирург', 'procedure': 'Операция на колене'},
        {'name': 'Ольга Сергеева', 'direction': 'ЛОР', 'procedure': 'Лечение ангины'},
        {'name': 'Анна Жукова', 'direction': 'Терапевт', 'procedure': 'Вакцинация'}
    ]

    queues = {
        'Терапевт': asyncio.Queue(),
        'Хирург': asyncio.Queue(),
        'ЛОР': asyncio.Queue()
    }

    producer_task = asyncio.create_task(producer(queues, patient_info))
    consumer_tasks = [asyncio.create_task(consumer(queues[doctor], doctor)) for doctor in queues]

    await producer_task  # Ожидаем завершения регистрации
    await asyncio.gather(*[queues[doctor].join() for doctor in queues])

    for task in consumer_tasks:
        task.cancel()

asyncio.run(main())



asyncio.Lock() — это замок.
Он нужен, чтобы ограничить доступ к какому-то ресурсу. Представь, что есть одна дверь, и только один человек может заходить внутрь. Остальные ждут, пока он выйдет.
    lock.acquire() асинхронно запрашивает блокировку. Является корутиной, используется с await. Если блокировка уже удерживается другой корутиной, текущая корутина будет
приостановлена (а не заблокирована в традиционном смысле) до тех пор, пока блокировка не станет доступной. Как только блокировка освобождается, она предоставляется одной
из ожидающих корутин, которая тем самым получает возможность безопасно использовать защищаемый ресурс.
    lock.release() освобождает блокировку, чтобы другой поток или корутина могли запросить ее.
    lock.locked() возвращает значение True, если блокировка в текущий момент захвачена, и False в противном случае.

import asyncio

# Создание объекта Lock
lock = asyncio.Lock()

async def my_task(task_id):
    print(f"Задача {task_id} ожидает блокировки с помощью Lock")
    # Ожидание получения блокировки
    await lock.acquire()
    try:
        print(f"Задача {task_id} получила блокировку")
        await asyncio.sleep(2)

    finally:
        print(f"Задача {task_id} блокировка снята")
        # Освобождение блокировки
        lock.release()

async def main():
    tasks = [asyncio.create_task(my_task(i)) for i in range(3)]
    await asyncio.gather(*tasks)

asyncio.run(main())



asyncio.Event() — это флажок или сигнал.
Он нужен, чтобы сообщить другим задачам, что что-то произошло. Представь светофор: пока он красный, машины стоят; когда зелёный — едут.
    event.set() - устанавливает флаг события в True. Это означает, что все задачи, которые вызывают метод wait(), прекратят блокирование и продолжат выполнение.
    event.clear() - устанавливает флаг события в False. Это означает, что все задачи, которые вызывают метод wait(), будут заблокированы, пока флаг не будет установлен в True.
    event.wait() - блокирует выполнение задачи, пока флаг события не будет установлен в True. Как только флаг будет установлен в True, метод wait() вернет управление и
задача продолжит выполнение. В противном случае блокируется до тех пор, пока другая задача не вызовет set().  wait() может привести к проблемам с производительностью,
если событие которое ожидает wait() долго не наступает, поэтому использовать его необходимо с осторожностью.
    event.is_set() - возвращает True, если флаг события установлен в True, и False в противном случае. Это полезно для проверки состояния флага, не блокируя выполнение задачи.

import asyncio

# Создаем экземпляр события
event = asyncio.Event()

# Определяем корутину для ожидания события
async def wait_for_event():
    print('Ждём события')
    # Ожидаем событие
    await event.wait()
    print('Событие получено')

# Определяем корутину для установки события
async def set_event():
    print('Установка события')
    # Устанавливаем событие
    event.set()

async def main():
    task1 = asyncio.create_task(wait_for_event())
    task2 = asyncio.create_task(set_event())
    await asyncio.gather(task1, task2)

asyncio.run(main())




Семафор — это способ, с помощью которого программы или потоки в компьютере договариваются между собой, чтобы не мешать друг другу при доступе к какому-то общему ресурсу,
например, к файлу, базе данных или участку памяти. Semaphore работает как счетчик, который уменьшается каждый раз, когда задача начинает использовать общий ресурс и увеличивается,
когда задача заканчивает использование ресурса. Если счетчик достигает нуля, это означает, что все доступные ресурсы используются, и новые задачи должны ждать, пока не освободится какой-либо ресурс.

    semaphore.acquire() - Этот метод запрашивает доступ к ресурсу. Если счетчик ресурсов больше нуля, то он уменьшается на 1, и метод возвращает True.
Если счетчик равен нулю, то метод блокируется, пока другая задача не вызовет метод release(). Метод является корутиной, должен использоваться с await.
    semaphore.release() - Этот метод освобождает ресурс, увеличивая счетчик на 1. Освобождение должно происходить после выполнения корутиной своей задачи.
    semaphore.locked() - Этот метод возвращает True, если счетчик ресурсов равен нулю, и False в противном случае.
    semaphore._value - Этот атрибут хранит текущее значение счетчика ресурсов. Является защищенным атрибутом, не рекомендован для использования в реальном коде,
но удобен при отладке и при изучении принципа работы семафора.

    asyncio.BoundedSemaphore(value)(ограниченный семафор) - это объект семафора, который используется для управления доступом к ресурсу в Python.
    Он позволяет ограничить количество одновременных доступов к ресурсу.

    .BoundedSemaphore реализован как обертка над asyncio.Semaphore. Он имеет дополнительный параметр "bound", который указывает максимальное количество
одновременных доступов к ресурсу.

    Ограниченный семафор - это то же самое, что и классический (неограниченный) семафор, за исключением того, что верхний предел семафора нельзя увеличить
множественным использованием функции release().


В асинхронном программировании на Python часто возникает необходимость синхронизировать выполнение нескольких задач, для этих целей в Python 3.11
был введен новый примитив синхронизации - asyncio.Barrier.

    barrier = asyncio.Barrier(3)
    wait(): Метод, который используется задачами для ожидания на барьере. Когда задача вызывает await barrier.wait(), она блокируется до тех пор, пока барьера не достигнет
    заданное количество задач (parties). Как только последняя необходимая задача вызовет wait(), все они одновременно разблокируются и смогут продолжить свое выполнение.
    wait() можно заменить использванием контекстного менеджера async with
    Этот метод может вызвать исключение asyncio.BrokenBarrierError, если барьер сломан или сброшен во время ожидания задачи. Метод также может вызвать asyncio.CancelledError,
    если задача будет отменена.

    reset(): Возвращает барьер в исходное состояние. Все задачи, ожидающие на барьере, получат исключение BrokenBarrierError. Является корутиной, должен ожидаться с await.
    При вызове reset() в момент, когда некоторые корутины уже ожидают у барьера, они также получат исключение BrokenBarrierError, так как состояние барьера неожиданно изменится.
    Однако в отличие от abort(), reset() позволяет барьеру быть повторно использованным после сброса.
    reset() предполагает контролируемый "перезапуск" барьера и подразумевает, что все участники знают о перезапуске и готовы начать новый цикл синхронизации.

    abort(): Переводит барьер в состояние "сломан". Все текущие и будущие вызовы wait() завершатся с исключением BrokenBarrierError.  Является корутиной, должен ожидаться с await.
    Предназначен для ситуаций, когда барьер должен быть немедленно сброшен из-за возникновения ошибки или иной непредвиденной ситуации, делающей дальнейшее ожидание барьера
    бессмысленным или невозможным. После вызова Barrier.abort(), барьер переходит в "сломанное" состояние, и любые последующие попытки использовать его приведут к
    немедленному возникновению BrokenBarrierError. Этот метод предназначен для прерывания работы с барьером и сигнализирует участникам о том, что совместная операция прервана
    и не может быть продолжена.

    parties: Возвращает количество задач, необходимых для прохождения барьера.

    n_waiting: Возвращает количество задач, ожидающих в данный момент на барьере.

    broken: Возвращает булево значение (True или False), указывающее на то, находится ли барьер в сломанном состоянии.



        Асинхронный файловый объект
Асинхронный файловый объект - это объект, который возвращает функция aiofiles.open(). Он предоставляет методы для асинхронного чтения и записи данных в файл

f.write(string): Асинхронно записывает строку string в файл. Возвращает количество записанных символов.

f.writelines(lines): Асинхронно записывает список строк lines в файл.

f.writable(None): Возвращает True, если файл открыт для записи, и False в противном случае.

f.read(n=-1): Асинхронно читает и возвращает до n символов из файла. Если n не указан или равен -1, читает и возвращает все символы до конца файла.

f.readline([size]): Асинхронно читает и возвращает информацию из одной строки файла. Если достигнут конец файла, возвращает пустую строку.

f.readlines([hint]): Асинхронно читает и возвращает строки файла в виде списка строк.

f.readinto(b): Асинхронно читает данные в предоставленный байтовый массив b, возвращает количество прочитанных байтов.

f.close(None): Асинхронно закрывает файл. После закрытия файла больше нельзя проводить никаких операций с ним.

f.flush(None): Асинхронно очищает буфер записи файла, если он поддерживает это.

f.isatty(None): Возвращает True, если файл подключен к терминалу, и False в противном случае.

f.read1(n=-1): Асинхронно читает и возвращает до n байт из файла, используя только один вызов системы ввода-вывода.

f.seek(offset, whence=0): Асинхронно изменяет позицию файла на offset байт, относительно whence.

f.seekable(None): Возвращает True, если в файле можно изменять позицию, и False в противном случае.

f.tell(None): Асинхронно возвращает текущую позицию указателя в байтах от начала файла.

f.truncate(size=None): Асинхронно урезает файл до size байт. Если size не указан, урезает файл до текущей позиции. Возвращает новый размер файла.