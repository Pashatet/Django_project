\n Новая строка

.	Любой символ, кроме символа новой строки. Если flags=re.DOTALL - любой символ.
\s Любой символ пробела, табуляции или новой строки.
\S Любой символ, кроме пробела, табуляции или новой строки.
\d	Любая цифра. Ищет все цифры: арабские, персидские, индийские, и так далее. Не эквивалентен [0-9]
\D	Любой символ, кроме цифр.
\w	Любая буква, цифра, или _. Шаблон не соответствует выражению [a-zA-Z0-9_]! Буквы используются не только латинские,
туда входит множество языков.
\W	Любой символ, кроме букв, цифр, и _.
\b Промежуток между символом, совпадающим с \w, и символом, не совпадающим с \w в любом порядке.
\B Промежуток между двумя символами, совпадающими с \w или \W.
\A	Начало всего текста
\Z	Конец всего текста
^	Начало всего текста или начало строчки текста, если flags=re.MULTILINE
$	Конец всего текста или конец строчки текста, если flags=re.MULTILINE
\1 которая указывает, что мы ищем повторение первой группы.
\r carriage return или CR, символ Юникода U+240D.

\t	Tab символ
\0 null, символ Юникода U+2400.
\v	Вертикальный пробел в Юникоде
\xYY

8-битный символ с заданным шестнадцатеричным значением.
Таблица юникода
Например \x2A находит символ *.
\ddd 8-битный символ с заданным восьмеричным значением. Таблица UTF-8
Например \052 находит символ *.

[\b] - Символ backspace или BS. В скобках, т.к. \b уже занято другим спецсимволом.

\f	Символ разрыва страницы.

{n}	Ровно n повторений
{m,n}	От m до n повторений.
{m,}	Не менее m повторений
{,n}	Не более n повторений

? - Ноль или одно повторение. То же, что и {0,1}
* - Ноль или более повторений. То же, что и {0,}
+ - Одно или более повторений. То же, что и {1,}

(regex)
Обыкновенная скобочная группа. Захватывает символы, о которых можно будет получить более подробную информацию.

(?P<name>regex)
Обычная скобочная группа, но вместе с номером ей будет присвоено имя name.

(?P<name>regex)(?P=name)
Скобочная группа с именем позволяет к ней обращаться и искать такой же текст, который она захватила.

(?(n)yes|no) В регулярных выражениях существуют условия. Если у группы n нашлись совпадения - возвращается шаблон до |.
В противном случае возвращается шаблон после |. Шаблон после | необязателен и может быть опущен.

(?=regex) - Проверяет, что шаблон стоит после выражения.
(?!regex) - Проверяет, что шаблон не стоит после выражения.
(?#regex) - Позволяет писать комментарии в регулярных выражениях.
(?<!regex) - Проверяет, что шаблон не стоит перед выражением.
(?(n)yes|no) - Если группа п найдена - ищет шаблон уе, иначе - по.
(?<=regex) - Проверяет, что шаблон стоит перед выражением.
(?:regex) - Позволяет группировать шаблоны.
(?:(?<=\w\s)|(?<=\W))
(?>x*) - соответствует нулю или более повторениям символа x, при этом не допускается обратный переход внутри группы.
То есть, если группа нашла подходящее совпадение, то это совпадение будет зафиксировано и больше не будет меняться.
(?>x+), (?>x?)

жадный квантификаток *+, ?+, ++
regexp = /".++"/g
"witch" and her "broom" is one
выдаст "witch" and her "broom"
ленивый квантификатор *?, ??, +?
regexp = /".+?"/g
"witch" and her "broom" is one
выдаст "witch", "broom"

re.search(pattern, string, flags=0) -  ищет первое совпадение в строке
re.match(pattern, string, flags=0) – то же самое, что и re.search(), но ищет совпадение в начале строки.
    Объект Match, если совпадение было найдено <re.Match object; span=(0, 3), match='123'>
    None, если нету совпадений

re.fullmatch(pattern, string, flags=0) - определяет соответствие строки переданному шаблону. Если вся строка соответствует шаблону - выводит объект Match, иначе - None.
    Объект Match, если вся строка соответствует шаблону
    None, если строка не соответствует шаблону

re.finditer(pattern, string, flags=0) - возвращает итератор Match объектов с вхождениями pattern в строке string.
    Итератор Match объектов

re.findall(pattern, string, flags=0) - возвращает список всех найденных совпадений.
    Список совпадений, если они есть
    Пустой список, если совпадений нет

re.split(pattern, string, maxsplit=0, flags=0) – разбивает строки по заданному паттерну.
    maxsplit - максимальное количество делений строки
    Если совпадения есть - список частей разделённой строки.
    [string], если совпадений нет
        import re
        pattern = r'\s\d{3}\s'
        string = 'abc 123 def 456 fed 321 cba'
        result = re.split(pattern, string)
        print(result) # ['abc', 'def', 'fed', 'cba']

re.sub(pattern, replace, string, count=0, flags=0) – заменяет найденные вхождения на заданные символы и возвращает исправленную строку.
    Если совпадения есть - изменённая строка
    string, если совпадений нет

re.subn(pattern, replace, string, count=0, flags=0) выполняет ту же операцию, что и функция re.sub(), но возвращает кортеж.
    Кортеж (new_string, number_of_subs), где
        new_string - новая строка, или старая, если не было совершено замен.
        number_of_subs - количество сделанных замен
    import re
    string = "Ненавижу людей, которые пишут дату в формате mm/dd/yyyy. Ну кто пишет 02/22/2022 или 07/13/2022?"
    print(re.sub(r'(\d{2}).(\d{2}).(\d{4})', r'\2.\1.\3', string))
    # Ненавижу людей, которые пишут дату в формате mm/dd/yyyy. Ну кто пишет 22.02.2022 или 13.07.2022?

re.escape(pattern) - экранирует специальные символы в pattern. Полезно, если нужно использовать полученную строку как
регулярное выражение, но в ней могут содержаться спецсимволы.
    import re
    print(re.escape(r'https://stepik.org/lesson/694442/step/1?unit=694231'))
    # Выводит https\:\/\/stepik\.org\/lesson\/694442\/step\/1\?unit\=694231

match.expand(template)
    import re
    match = re.search(r"(\d{4})", "Бойцовский клуб (1999)"
    print(match.expand(r"Год выпуска фильма: \1"))    # Год выпуска фильма: 1999

